<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å…¸ç‹±é•¿æ ¼èµ«ç½—æ–¯ Beta 0.5</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=DotGothic16&display=swap" rel="stylesheet">

    <style>
        body {
            margin: 0; padding: 0;
            background-color: #050505;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            font-family: 'DotGothic16', sans-serif; 
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            max-width: 600px; 
            aspect-ratio: 256/240;
            background: #000;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated; 
        }

        /* å¯åŠ¨å°é¢ */
        #startScreen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 50; color: #fff; text-align: center;
        }
        .blink { animation: blinker 1s linear infinite; }
        @keyframes blinker { 50% { opacity: 0; } }

        /* ç»“ç®—ç•Œé¢ */
        #resultScreen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: none; flex-direction: column; justify-content: center; align-items: center;
            z-index: 30; color: #fff; text-align: center;
            animation: fadeIn 0.5s ease-in;
        }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        .title-text { font-size: 32px; margin-bottom: 20px; text-shadow: 4px 4px #f00; }
        .info-text { font-size: 16px; color: #ccc; margin-bottom: 30px; }
        
        .btn {
            border: 2px solid #fff; background: #222; color: #fff;
            padding: 15px 40px; font-size: 20px; margin-top: 20px; 
            font-family: 'DotGothic16', sans-serif; cursor: pointer;
            image-rendering: pixelated;
        }
        .btn:hover { background: #444; }

        #fileInputOverlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); display: none; 
            flex-direction: column; justify-content: center; align-items: center; color: #fff; z-index: 40;
        }
    </style>
</head>
<body>

<div id="gameContainer">
    <canvas id="gameCanvas"></canvas>

    <!-- å¯åŠ¨å°é¢ (æ–°å¢) -->
    <div id="startScreen">
        <div class="title-text">å…¸ç‹±é•¿æ ¼èµ«ç½—æ–¯</div>
        <div class="info-text">ç‚¹å‡»å±å¹•å¼€å§‹æŒ‘æˆ˜</div>
        <div class="blink" style="font-size: 24px;">â–¶ PRESS START</div>
    </div>

    <!-- ç»“ç®—ç•Œé¢ -->
    <div id="resultScreen">
        <div id="resultTitle" style="font-size: 40px; margin-bottom: 10px;"></div>
        <div id="resultDesc" style="font-size: 16px; color: #ccc; line-height: 1.8;"></div>
        <button class="btn" onclick="restartGame()">å†æ¬¡å°è¯•</button>
    </div>

    <!-- å¤‡ç”¨ä¸Šä¼  -->
    <div id="fileInputOverlay">
        <p style="font-size: 20px; margin-bottom: 20px;">æœªæ£€æµ‹åˆ° boss.png</p>
        <button class="btn" onclick="document.getElementById('manualLoader').click()">ğŸ“‚ è½½å…¥å›¾åƒ</button>
        <input type="file" id="manualLoader" accept="image/*" style="display:none" onchange="handleManualLoad(this)">
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const startScreen = document.getElementById('startScreen');
    const resultScreen = document.getElementById('resultScreen');
    const fileOverlay = document.getElementById('fileInputOverlay');

    const NES_W = 256;
    const NES_H = 240;
    canvas.width = NES_W;
    canvas.height = NES_H;

    // --- èµ„æºåŠ è½½ ---
    const bossImg = new Image();
    let isImageLoaded = false;
    
    // éŸ³ä¹å¯¹è±¡
    const bgm = new Audio();
    bgm.src = 'bgm.mp3'; 
    bgm.loop = true;     
    bgm.volume = 0.5;    

    // å°è¯•åŠ è½½å›¾ç‰‡
    bossImg.src = 'boss.png'; 
    
    bossImg.onload = function() { 
        isImageLoaded = true; 
        fileOverlay.style.display = 'none'; 
        // å›¾ç‰‡åŠ è½½å¥½äº†ï¼Œä½†æˆ‘ä»¬ä¸æ€¥ç€initï¼Œç­‰ç”¨æˆ·ç‚¹å‡»å¼€å§‹
    };

    bossImg.onerror = function() { 
        // å›¾ç‰‡æŒ‚äº†ï¼Œæ˜¾ç¤ºæ‰‹åŠ¨ä¸Šä¼ 
        fileOverlay.style.display = 'flex'; 
    };

    function handleManualLoad(input) {
        if (input.files && input.files[0]) {
            const reader = new FileReader();
            reader.onload = function(e) { 
                bossImg.src = e.target.result; 
                isImageLoaded = true;
                fileOverlay.style.display = 'none';
            }
            reader.readAsDataURL(input.files[0]);
        }
    }

    // --- æ¸¸æˆå‚æ•° ---
    const STATE = { MENU: -1, WAITING: 0, AIMING: 1, FIRING: 2, ENEMY: 3, END: 4 };
    let currentState = STATE.MENU; // åˆå§‹çŠ¶æ€æ”¹ä¸ºèœå•
    let frame = 0;
    
    let player = { hp: 100, max: 100 };
    let boss = { hp: 300, max: 300, flashTimer: 0, recoil: 0 }; 
    
    let dialogue = "è­¦å‘Šï¼šå‰æ–¹é«˜èƒ½ååº”ï¼";
    let bar = { w: 180, h: 14, y: 175, pos: 0, speed: 9, dir: 1, hitStart: 0, hitW: 16 };
    
    let shotCount = 0;
    let shotTimer = 0;
    let isCrit = false;
    let isHit = false;

    let particles = [];
    let shake = 0;
    let flash = 0;
    let flashColor = '#eee';
    let dodgeAnim = 0;
    let uiSwayTimer = 0; 

    // å¯åŠ¨æ¸¸æˆ (ç‚¹å‡»å°é¢åè§¦å‘)
    function startGameByUser() {
        startScreen.style.display = 'none';
        currentState = STATE.WAITING;
        
        // æ’­æ”¾éŸ³ä¹ (å¿…é¡»åœ¨ç”¨æˆ·ç‚¹å‡»äº‹ä»¶ä¸­è°ƒç”¨)
        bgm.play().catch(e => console.log("BGMæ’­æ”¾å¤±è´¥(å¯èƒ½æ˜¯æ–‡ä»¶è·¯å¾„é”™è¯¯):", e));
        
        init();
    }

    function init() { resetZone(); loop(); }

    function resetZone() {
        bar.hitStart = Math.floor(Math.random() * (bar.w - bar.hitW));
        bar.pos = 0;
        bar.dir = 1;
    }

    function restartGame() {
        resultScreen.style.display = 'none';
        player.hp = 100;
        boss.hp = 300;
        particles = [];
        currentState = STATE.WAITING;
        dialogue = "é‡æ–°æ¥æ•Œï¼Œä¿æŒè­¦æƒ•ï¼";
        
        shake = 0;
        flash = 0;
        shotCount = 0;
        shotTimer = 0;
        dodgeAnim = 0;
        boss.flashTimer = 0;
        boss.recoil = 0;
        uiSwayTimer = 0;

        // ç¡®ä¿éŸ³ä¹åœ¨æ’­æ”¾
        if(bgm.paused) bgm.play().catch(e=>{});
    }

    function update() {
        if (currentState === STATE.MENU) return; // èœå•çŠ¶æ€ä¸æ›´æ–°é€»è¾‘

        if (shake > 0) shake--;
        if (flash > 0) flash--;
        if (boss.flashTimer > 0) boss.flashTimer--;
        
        if (boss.recoil > 0) boss.recoil *= 0.8;
        if (Math.abs(boss.recoil) < 0.5) boss.recoil = 0;

        if (dodgeAnim !== 0) {
            dodgeAnim = dodgeAnim * 0.8;
            if (Math.abs(dodgeAnim) < 1) dodgeAnim = 0;
        }
        
        if (uiSwayTimer > 0) uiSwayTimer--;

        updateParticles();

        if (currentState === STATE.END) return;

        if (currentState === STATE.AIMING) {
            bar.pos += bar.speed * bar.dir;
            if (bar.pos >= bar.w || bar.pos <= 0) bar.dir *= -1;
        }
        else if (currentState === STATE.FIRING) {
            shotTimer--;
            if (shotTimer <= 0 && shotCount < 3) {
                shotTimer = 8; 
                fireOneShot();
                shotCount++;
            }
            if (shotCount >= 3 && shotTimer <= -25) {
                if (currentState !== STATE.END) {
                    if (boss.hp <= 0) {
                        endGame(true);
                    } else {
                        dialogue = "æ ¼èµ«ç½—æ–¯ æ­£åœ¨èšèƒ½...";
                        currentState = STATE.ENEMY;
                        frame = 1;
                    }
                }
            }
        }
        else if (currentState === STATE.ENEMY) {
            if (frame % 60 === 0) {
                
                let roll = Math.random(); 
                const uiCenterY = 197;

                if (roll < 0.15) {
                    spawnParticle('player_dodge', "é—ªé¿!", NES_W - 40, NES_H - 35, '#0ff');
                    dialogue = "æ®‹å½±ç¬ç§»ï¼";
                    dodgeAnim = 30; 
                }
                else if (roll < 0.20) {
                    spawnParticle('player_miss', "MISS", NES_W - 40, NES_H - 35, '#0f0');
                    dialogue = "æ”»å‡»åç¦»ï¼";
                    uiSwayTimer = 60; 
                }
                else if (roll < 0.30) {
                    const dmg = 9999999;
                    player.hp -= dmg;
                    if (player.hp < 0) player.hp = 0;

                    spawnDeathBoom(NES_W/2, uiCenterY);
                    shake = 50; flash = 40; flashColor = '#f00';
                    
                    spawnParticle('mega_text', "-9999999", NES_W - 90, NES_H - 30, '#f00');
                    dialogue = "ç»æœ›é™ä¸´ï¼ï¼ï¼";
                    endGame(false);
                    return;
                }
                else {
                    const dmg = 34; 
                    player.hp -= dmg;
                    if (player.hp < 0) player.hp = 0;

                    spawnPixelExplosion(NES_W/2, uiCenterY);
                    shake = 25; flash = 12; flashColor = '#f00';
                    
                    spawnParticle('player_hurt', "-" + dmg, NES_W - 40, NES_H - 35, '#ff3333');
                    dialogue = "è£…ç”²ä¸¥é‡å—æŸï¼";

                    if (player.hp <= 0) {
                        endGame(false);
                        return; 
                    }
                }

                if (player.hp > 0) {
                    currentState = STATE.WAITING;
                    setTimeout(() => {
                        if (currentState !== STATE.END) {
                            dialogue = "è¶ç°åœ¨ï¼Œåå‡»ï¼";
                            resetZone();
                        }
                    }, 600);
                }
            }
        }
    }

    function fireOneShot() {
        if (currentState === STATE.END) return; 

        const spread = 40;
        const tx = NES_W/2 + (Math.random() - 0.5) * spread;
        const ty = 90 + (Math.random() - 0.5) * spread;

        spawnParticle('crosshair', null, tx, ty);

        if (isHit) {
            let baseDmg = isCrit ? 60 : 35; 
            let dmg = baseDmg + Math.floor(Math.random() * 6 - 3);
            
            boss.hp -= dmg;
            if (boss.hp < 0) boss.hp = 0;
            boss.flashTimer = 5;
            
            if (isCrit) {
                spawnParticle('text', "æš´å‡» " + dmg, tx, ty, '#0ff');
                shake = 15; boss.recoil = 15; flash = 5; flashColor = '#eee';
                spawnHitSparks(tx, ty, 10, '#0ff');
            } else {
                spawnParticle('text', "-" + dmg, tx, ty, '#fff');
                shake = 8; boss.recoil = 5; 
                spawnHitSparks(tx, ty, 5, '#fd0');
            }

            if (boss.hp <= 0) {
                endGame(true);
            }

        } else {
            spawnParticle('text', "MISS", tx, ty, '#888');
        }
    }

    function endGame(isWin) {
        currentState = STATE.END;
        setTimeout(() => {
            showResult(isWin);
        }, 1000);
    }

    function spawnParticle(type, text, x, y, color) {
        let p = { 
            type: type, life: 30, maxLife:30, 
            x: x, y: y, 
            text: text, color: color || '#fff',
            radius: 10, vx: 0, vy: 0 
        };
        if (type === 'mega_text') { p.life = 60; p.maxLife = 60; }
        if (type === 'player_miss' || type === 'player_dodge' || type === 'player_hurt') { 
            p.life = 50; p.maxLife = 50; 
        }
        particles.push(p);
    }

    function spawnHitSparks(x, y, count, color) {
        for(let i=0; i<count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 2 + Math.random() * 4;
            particles.push({
                type: 'spark', life: 20, x: x, y: y,
                vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,
                color: color
            });
        }
    }

    function spawnPixelExplosion(x, y) {
        particles.push({ type: 'nes_boom', x: x, y: y, life: 12, maxLife: 12, scale: 1, color: '#fff' });
    }

    function spawnDeathBoom(x, y) {
        particles.push({ type: 'nes_boom', x: x, y: y, life: 20, maxLife: 20, scale: 3, color: '#f00' });
        particles.push({ type: 'nes_boom', x: x-20, y: y+20, life: 25, maxLife: 25, scale: 2, color: '#000' });
        particles.push({ type: 'nes_boom', x: x+20, y: y-20, life: 25, maxLife: 25, scale: 2, color: '#500' });
    }

    function updateParticles() {
        for(let i=particles.length-1; i>=0; i--) {
            let p = particles[i];
            p.life--;
            
            if (p.type === 'text') p.y -= 0.5;
            if (p.type === 'mega_text') { p.x += (Math.random()-0.5) * 4; p.y += (Math.random()-0.5) * 4; }
            if (p.type === 'player_miss' || p.type === 'player_dodge' || p.type === 'player_hurt') { p.y -= 0.3; }
            if (p.type === 'spark') { p.x += p.vx; p.y += p.vy; p.vy += 0.2; }
            if (p.life <= 0) particles.splice(i, 1);
        }
    }

    function drawParticles() {
        particles.forEach(p => {
            ctx.font = "12px 'DotGothic16', sans-serif"; 

            if (p.type === 'text') {
                ctx.save(); ctx.fillStyle = p.color; 
                ctx.textAlign = "center"; ctx.strokeStyle = "#000"; ctx.lineWidth = 2;
                ctx.strokeText(p.text, p.x, p.y); ctx.fillText(p.text, p.x, p.y); ctx.restore();
            } 
            else if (p.type === 'mega_text') {
                ctx.save(); ctx.fillStyle = p.color; 
                ctx.font = "28px 'DotGothic16', sans-serif";
                ctx.textAlign = "center"; ctx.shadowColor = "#f00"; ctx.shadowBlur = 10;
                ctx.strokeStyle = "#fff"; ctx.lineWidth = 3;
                ctx.strokeText(p.text, p.x, p.y); ctx.fillText(p.text, p.x, p.y); ctx.restore();
            }
            else if (p.type === 'player_miss' || p.type === 'player_dodge') {
                ctx.save(); ctx.fillStyle = p.color; 
                ctx.font = "16px 'DotGothic16', sans-serif";
                ctx.textAlign = "center"; ctx.strokeStyle = "#000"; ctx.lineWidth = 2;
                ctx.strokeText(p.text, p.x, p.y); ctx.fillText(p.text, p.x, p.y); ctx.restore();
            }
            else if (p.type === 'player_hurt') {
                ctx.save(); ctx.fillStyle = p.color; 
                ctx.font = "20px 'DotGothic16', sans-serif"; 
                ctx.textAlign = "center"; 
                ctx.shadowColor = "#000"; ctx.shadowBlur = 2;
                ctx.strokeText(p.text, p.x, p.y); ctx.fillText(p.text, p.x, p.y); 
                ctx.restore();
            }
            else if (p.type === 'crosshair') {
                ctx.save(); ctx.strokeStyle = "#fff"; ctx.lineWidth = 2;
                const r = 8; const ext = 4;
                ctx.beginPath(); ctx.arc(p.x, p.y, r, 0, Math.PI*2); ctx.stroke();
                ctx.beginPath(); 
                ctx.moveTo(p.x - r - ext, p.y); ctx.lineTo(p.x + r + ext, p.y);
                ctx.moveTo(p.x, p.y - r - ext); ctx.lineTo(p.x, p.y + r + ext);
                ctx.stroke();
                ctx.fillStyle = "red"; ctx.fillRect(p.x-1, p.y-1, 2, 2); ctx.restore();
            }
            else if (p.type === 'spark') {
                ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, 2, 2);
            }
            else if (p.type === 'nes_boom') {
                let stage = 0;
                let progress = p.life / p.maxLife;
                if (progress > 0.66) stage = 1; else if (progress > 0.33) stage = 2; else stage = 3;
                drawNESBoomShape(ctx, p.x, p.y, stage, p.scale, p.color);
            }
        });
    }

    function drawNESBoomShape(ctx, x, y, stage, scale, color) {
        ctx.save();
        ctx.translate(x, y); ctx.scale(scale, scale); ctx.translate(-x, -y);
        ctx.fillStyle = color || "#FFFFFF";
        if (stage === 1) { 
            ctx.fillRect(x-4, y-4, 8, 8);
            ctx.fillRect(x-12, y-2, 24, 4); ctx.fillRect(x-2, y-12, 4, 24);
            ctx.fillRect(x-8, y-8, 4, 4); ctx.fillRect(x+4, y-8, 4, 4);
            ctx.fillRect(x-8, y+4, 4, 4); ctx.fillRect(x+4, y+4, 4, 4);
        } else if (stage === 2) {
            ctx.fillRect(x-10, y-10, 20, 20); ctx.clearRect(x-4, y-4, 8, 8);
            ctx.fillRect(x-14, y-6, 4, 12); ctx.fillRect(x+10, y-6, 4, 12);
            ctx.fillRect(x-6, y-14, 12, 4); ctx.fillRect(x-6, y+10, 12, 4);
        } else if (stage === 3) {
            ctx.fillRect(x-14, y-14, 8, 8); ctx.fillRect(x+6, y-14, 8, 8);
            ctx.fillRect(x-14, y+6, 8, 8); ctx.fillRect(x+6, y+6, 8, 8);
            ctx.fillRect(x-6, y-6, 12, 12);
        }
        ctx.restore();
    }

    function showResult(isWin) {
        // åœæ­¢èƒŒæ™¯éŸ³ä¹
        bgm.pause();
        
        resultScreen.style.display = 'flex';
        const titleDiv = document.getElementById('resultTitle');
        const descDiv = document.getElementById('resultDesc');
        
        if (isWin) {
            if (player.hp === 100) titleDiv.innerText = "å®Œç¾æ— ç‘•çš„èƒœåˆ©";
            else titleDiv.innerText = "å¥‡è¿¹èˆ¬çš„èƒœåˆ©";
            titleDiv.className = "result-title win-title";
            
            let rank = "B";
            if (player.hp === 100) rank = "S+";
            else if (player.hp >= 66) rank = "S";
            else if (player.hp >= 32) rank = "A+";
            
            descDiv.innerHTML = `å‰©ä½™ç”Ÿå‘½: ${player.hp}%<br>ä½ å‡»è´¥äº†å…¸ç‹±é•¿æ ¼èµ«ç½—æ–¯<br>è¯„ä»·: <span style="color:#ff0; font-size:20px;">${rank}</span>`;
        } else {
            titleDiv.innerText = "å½»åº•çš„ç»æœ›";
            titleDiv.className = "result-title lose-title";
            descDiv.innerHTML = `BOSS å‰©ä½™è¡€é‡: ${boss.hp}<br>å…¸ç‹±é•¿æ ¼èµ«ç½—æ–¯å‡»è´¥äº†ä½ `;
        }
    }

    function draw() {
        let renderX = 0;
        if (dodgeAnim !== 0) renderX = dodgeAnim;

        if (flash > 0 && Math.floor(frame/2)%2===0) {
            ctx.fillStyle = flashColor;
        } else {
            ctx.fillStyle = '#050505';
        }
        ctx.fillRect(0, 0, NES_W, NES_H);

        let dx = 0, dy = 0;
        if (shake > 0) {
            dx = (Math.random() - 0.5) * shake;
            dy = (Math.random() - 0.5) * shake;
        }

        ctx.save();
        if (Math.abs(dodgeAnim) > 1) {
            ctx.save(); ctx.translate(dx - dodgeAnim * 0.5, dy); 
            ctx.globalAlpha = 0.5; ctx.globalCompositeOperation = "lighter";
            drawUIContent(); ctx.restore();
        }
        ctx.translate(dx + renderX, dy);
        drawUIContent();
        drawParticles();
        ctx.restore();
    }

    function drawUIContent() {
        ctx.font = "12px 'DotGothic16', sans-serif";

        ctx.fillStyle = "#666"; ctx.textAlign = "center";
        ctx.fillText("å…¸ç‹±é•¿æ ¼èµ«ç½—æ–¯", NES_W/2, 10);

        const bossTitle = "å…¸ç‹±é•¿æ ¼èµ«ç½—æ–¯";
        const metrics = ctx.measureText(bossTitle);
        const barW = metrics.width + 10; 
        drawBar(NES_W/2 - barW/2, 22, barW, 6, boss.hp, boss.max, '#d00');

        ctx.fillStyle = "#ffffff"; ctx.beginPath();
        ctx.ellipse(NES_W/2, 125, 42, 10, 0, 0, Math.PI * 2); ctx.fill();

        if (isImageLoaded) {
            let bx = (Math.random()-0.5) * boss.recoil;
            let by = (Math.random()-0.5) * boss.recoil;
            ctx.save(); ctx.translate(bx, by); 
            if (boss.flashTimer > 0) {
                ctx.filter = "brightness(500%)";
                drawBossImage();
                ctx.filter = "none";
            } else {
                drawBossImage();
            }
            ctx.restore();
        }

        const boxH = 65; const boxY = NES_H - boxH - 10;
        
        let swayX = 0;
        if (uiSwayTimer > 0) {
            swayX = Math.sin(frame * 0.1) * 10 * (uiSwayTimer / 60);
        }

        ctx.save();
        ctx.translate(swayX, 0); 

        ctx.fillStyle = "#000"; ctx.fillRect(10, boxY, NES_W-20, boxH);
        ctx.strokeStyle = "#fff"; ctx.lineWidth = 2; ctx.strokeRect(10, boxY, NES_W-20, boxH);

        let isPlayerTurn = (currentState === STATE.WAITING || currentState === STATE.AIMING || currentState === STATE.FIRING);
        let isBossTurn = (currentState === STATE.ENEMY);

        if (isBossTurn) {
            ctx.fillStyle = "#000"; ctx.fillRect(10, boxY - 16, 64, 16);
            ctx.strokeStyle = "#fff"; ctx.strokeRect(10, boxY - 16, 64, 16);
            ctx.fillStyle = "#fff"; ctx.textAlign = "center"; 
            ctx.fillText("æ ¼èµ«ç½—æ–¯", 10 + 32, boxY - 3);
        }

        if (isPlayerTurn) {
            ctx.fillStyle = "#000"; ctx.fillRect(NES_W - 10 - 36, boxY - 16, 36, 16);
            ctx.strokeStyle = "#fff"; ctx.strokeRect(NES_W - 10 - 36, boxY - 16, 36, 16);
            ctx.fillStyle = "#fff"; ctx.textAlign = "center"; 
            ctx.fillText("ç©å®¶", NES_W - 10 - 18, boxY - 3);
        }

        ctx.textAlign = "right"; 
        let hpColor = player.hp > 35 ? '#0f0' : '#f00';
        drawBar(NES_W - 60, boxY + 10, 40, 6, player.hp, player.max, hpColor);
        ctx.fillStyle = "#fff"; 
        ctx.fillText("HP", NES_W - 65, boxY + 16);

        ctx.fillStyle = "#fff"; ctx.textAlign = "left";
        ctx.fillText(dialogue, 20, boxY + 25);
        
        if (currentState !== STATE.ENEMY && currentState !== STATE.END) {
            const bx = (NES_W - bar.w)/2;
            const by = boxY + 45; 
            ctx.fillStyle = "#000"; ctx.fillRect(bx, by, bar.w, bar.h);
            ctx.strokeStyle = "#666"; ctx.lineWidth = 1; ctx.strokeRect(bx, by, bar.w, bar.h);
            ctx.fillStyle = "#fff"; ctx.fillRect(bx + bar.hitStart, by+1, bar.hitW, bar.h-2);
            ctx.fillStyle = "#f00"; ctx.fillRect(bx + bar.pos - 2, by-1, 5, bar.h+2);
        }
        
        ctx.restore();
    }

    function drawBossImage() {
        if (!isImageLoaded) return;
        const maxH = 85; 
        const ratio = bossImg.width / bossImg.height;
        const drawH = maxH;
        const drawW = maxH * ratio;
        const x = (NES_W - drawW) / 2;
        const y = 45; 
        ctx.drawImage(bossImg, x, y, drawW, drawH);
    }

    function drawBar(x, y, w, h, val, max, color) {
        ctx.fillStyle = "#222"; ctx.fillRect(x, y, w, h);
        ctx.fillStyle = color;
        const wFill = Math.max(0, (val/max)*w);
        ctx.fillRect(x, y, wFill, h);
    }

    function handleInput(e) {
        if (!isImageLoaded || currentState === STATE.END) return;
        if (e.target.tagName === 'BUTTON') return;
        e.preventDefault();

        // ç‚¹å‡»å¼€å§‹å°é¢äº‹ä»¶
        if (currentState === STATE.MENU) {
            startScreen.style.display = 'none';
            currentState = STATE.WAITING;
            // æ’­æ”¾ BGM
            bgm.currentTime = 0;
            bgm.play().catch(e => console.log("BGMéœ€è¦äº¤äº’"));
            init();
            return;
        }

        if (currentState === STATE.WAITING) {
            currentState = STATE.AIMING;
        }
        else if (currentState === STATE.AIMING) {
            let hitL = bar.hitStart;
            let hitR = bar.hitStart + bar.hitW;
            const center = hitL + bar.hitW/2;
            
            if (bar.pos >= hitL && bar.pos <= hitR) {
                isHit = true;
                isCrit = (Math.abs(bar.pos - center) < bar.hitW * 0.25);
            } else {
                isHit = false; isCrit = false;
            }
            currentState = STATE.FIRING;
            shotCount = 0; shotTimer = 0;
        }
    }

    function loop() { frame++; update(); draw(); requestAnimationFrame(loop); }
    window.addEventListener('mousedown', handleInput);
    window.addEventListener('touchstart', handleInput, {passive: false});

    // ç‚¹å‡»å°é¢å¼€å§‹é€»è¾‘
    startScreen.addEventListener('mousedown', handleInput);
    startScreen.addEventListener('touchstart', handleInput);

</script>
</body>
</html>
