<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å…¸ç‹±é•¿æ ¼èµ«ç½—æ–¯ - Beta 0.5.13</title>

    <!-- åƒç´ é£å­—ä½“ -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=DotGothic16&display=swap" rel="stylesheet">

    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #050505;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            font-family: 'DotGothic16', 'Courier New', monospace;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            max-width: 600px;
            aspect-ratio: 256/240;
            background: #000;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
            text-align: center;
            pointer-events: auto;
        }

        #startScreen {
            background: #000000;
            z-index: 60;
        }

        /* ç»“ç®—ç”»é¢ï¼šåŠé€æ˜é»‘åº•ï¼Œå…¨å±é®ç½© */
        #resultScreen {
            background: rgba(0, 0, 0, 0.85);
            display: none;
            z-index: 70;
            animation: fadeIn 0.5s ease-in forwards;
        }

        #expertPrompt {
            background: rgba(0, 0, 0, 0.95);
            z-index: 75;
        }

        #fileInputOverlay {
            background: rgba(0, 0, 0, 0.95);
            display: none;
            z-index: 80;
        }

        /* é€šå…³å‰§æƒ…ç”»é¢ */
        #endingScreen {
            background: rgba(0, 0, 0, 0.92);
            z-index: 85;
            padding: 24px;
            box-sizing: border-box;
        }

        #endingLines {
            font-size: 20px;
            line-height: 1.8;
            text-shadow: 2px 2px #000;
            text-align: center;
            max-width: 90vw;
        }

        .ending-line {
            opacity: 0;
        }

        .fade-in-slow {
            animation: fadeInSlow 1.5s forwards;
        }

        .fade-delay-1 {
            animation-delay: 0.7s;
        }

        .fade-delay-2 {
            animation-delay: 1.4s;
        }

        #endingButtons {
            margin-top: 24px;
            display: flex;
            justify-content: center;
            gap: 16px;
            flex-wrap: wrap;
        }

        #endingHint {
            margin-top: 24px;
            font-size: 18px;
            color: #ff0;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to   { opacity: 1; }
        }

        @keyframes fadeInSlow {
            from { opacity: 0; }
            to   { opacity: 1; }
        }

        .blink {
            animation: blinker 1s linear infinite;
        }

        @keyframes blinker {
            50% { opacity: 0; }
        }

        .result-title {
            font-size: 40px;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 4px 4px #000;
        }

        .result-desc {
            font-size: 16px;
            color: #ccc;
            line-height: 1.8;
        }

        .win-title { color: #0f0; }
        .lose-title { color: #f00; }

        .btn {
            border: 2px solid #fff;
            background: #222;
            color: #fff;
            padding: 10px 20px;
            font-size: 18px;
            margin-top: 10px;
            font-family: inherit;
            cursor: pointer;
            image-rendering: pixelated;
        }

        #resultButtons {
            margin-top: 20px;
            display: flex;
            justify-content: center;
            gap: 16px;
            flex-wrap: wrap;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
<div id="gameContainer">
    <canvas id="gameCanvas"></canvas>

    <!-- å°é¢ -->
    <div id="startScreen" class="overlay">
        <div class="result-title" style="margin-bottom: 50px;">å…¸ç‹±é•¿æ ¼èµ«ç½—æ–¯</div>
        <div id="pressStartBtn" class="blink" style="font-size: 24px; color: #ff0;">
            â–¶ ç‚¹å‡»å±å¹•å¼€å§‹
        </div>
    </div>

    <!-- ç»“ç®—ç”»é¢ -->
    <div id="resultScreen" class="overlay">
        <div id="resultTitle" class="result-title"></div>
        <div id="resultDesc" class="result-desc"></div>
        <div id="resultButtons">
            <button id="btnPrimary" class="btn" onclick="onResultPrimaryClick()">ä»»åŠ¡å®Œæˆ</button>
            <button id="btnSecondary" class="btn hidden" onclick="onResultSecondaryClick()">æ”¾å¼ƒ</button>
        </div>
    </div>

    <!-- ä¸“å®¶æ¨¡å¼ç¡®è®¤ï¼ˆæ—§çš„ï¼Œæš‚æ—¶ä¸å†ä½¿ç”¨ï¼Œä½†ä¿ç•™ç»“æ„ä»¥å…æŠ¥é”™ï¼‰ -->
    <div id="expertPrompt" class="overlay hidden">
        <div style="font-size: 20px; margin-bottom: 20px; text-shadow: 2px 2px #000;">
            æ˜¯å¦æŒ‘æˆ˜ä¸“å®¶éš¾åº¦ï¼Ÿ
        </div>
        <div>
            <button class="btn" onclick="chooseExpert(true)" style="margin-right: 16px;">æ˜¯</button>
            <button class="btn" onclick="chooseExpert(false)">å¦</button>
        </div>
    </div>

    <!-- é€šå…³å‰§æƒ…ç”»é¢ -->
    <div id="endingScreen" class="overlay hidden">
        <div id="endingLines"></div>
        <div id="endingButtons" class="hidden">
            <button id="endingBtnExpert" class="btn">æŒ‘æˆ˜ä¸“å®¶æ¨¡å¼</button>
            <button id="endingBtnTitle" class="btn">å›åˆ°æ¸¸æˆå¼€å¤´</button>
        </div>
        <div id="endingHint" class="blink hidden">
            ç‚¹å‡»å±å¹•å›åˆ°æ¸¸æˆå¼€å¤´
        </div>
    </div>

    <!-- boss.png è½½å…¥æç¤º -->
    <div id="fileInputOverlay" class="overlay">
        <p style="font-size: 20px; margin-bottom: 20px;">æœªæ£€æµ‹åˆ° boss.png</p>
        <button class="btn" onclick="document.getElementById('manualLoader').click()">ğŸ“‚ è½½å…¥å›¾åƒ</button>
        <input type="file" id="manualLoader" accept="image/*" style="display:none"
               onchange="handleManualLoad(this)">
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const startScreen = document.getElementById('startScreen');
    const resultScreen = document.getElementById('resultScreen');
    const fileOverlay = document.getElementById('fileInputOverlay');
    const resultTitle = document.getElementById('resultTitle');
    const resultDesc = document.getElementById('resultDesc');
    const expertPrompt = document.getElementById('expertPrompt');
    const btnPrimary = document.getElementById('btnPrimary');
    const btnSecondary = document.getElementById('btnSecondary');

    const endingScreen = document.getElementById('endingScreen');
    const endingLines = document.getElementById('endingLines');
    const endingButtons = document.getElementById('endingButtons');
    const endingHint = document.getElementById('endingHint');
    const endingBtnExpert = document.getElementById('endingBtnExpert');
    const endingBtnTitle = document.getElementById('endingBtnTitle');

    const NES_W = 256;
    const NES_H = 240;
    canvas.width = NES_W;
    canvas.height = NES_H;

    // boss å›¾ç‰‡
    const bossImg = new Image();
    let isImageLoaded = false;

    bossImg.onload = function () {
        isImageLoaded = true;
    };
    bossImg.onerror = function () {
        console.log("Image failed");
    };
    bossImg.src = 'boss.png';

    // éŸ³é¢‘
    const audioAssets = {
        bgm: new Audio('bgm.mp3'),
        shoot: new Audio('player_shoot.mp3'),
        hit: new Audio('boss_hit.mp3'),
        kill: new Audio('boss_kill.mp3')
    };
    audioAssets.bgm.loop = true;
    audioAssets.bgm.volume = 1.0;

    function playSfx(name) {
        try {
            const original = audioAssets[name];
            if (original) {
                const clone = original.cloneNode();
                clone.volume = 0.4;
                clone.play().catch(() => {});
            }
        } catch (e) {
            console.log("Audio Error:", e);
        }
    }

    function handleManualLoad(input) {
        if (input.files && input.files[0]) {
            const reader = new FileReader();
            reader.onload = function (e) {
                bossImg.src = e.target.result;
                fileOverlay.style.display = 'none';
            };
            reader.readAsDataURL(input.files[0]);
        }
    }

    // çŠ¶æ€
    const STATE = {MENU: 0, WAITING: 1, AIMING: 2, FIRING: 3, ENEMY: 4, END: 5};
    let currentState = STATE.MENU;
    let frame = 0;

    let player = {hp: 100, max: 100};
    let boss = {hp: 300, max: 300, flashTimer: 0, recoil: 0};

    let dialogue = "è­¦å‘Šï¼šå‰æ–¹é«˜èƒ½ååº”ï¼";

    let bar = {
        w: 180,
        h: 14,
        y: 175,
        pos: 0,
        speed: 11,
        dir: 1,
        hitStart: 0,
        hitW: 16,
        moveDir: 1
    };

    let shotCount = 0;
    let shotTimer = 0;
    let isCrit = false;
    let isHit = false;

    let particles = [];
    let shake = 0;
    let flash = 0;
    let flashColor = '#eee';
    let dodgeAnim = 0;
    let uiSwayTimer = 0;

    let isExpertMode = false;
    let lastResultIsWin = false;

    let lastTime = 0;
    const FPS = 60;
    const interval = 1000 / FPS;

    // é€šå…³æ¨¡å¼ï¼šnormal / expert / null
    let endingMode = null;

    resetZone();
    loop(0);

    function resetZone() {
        bar.hitStart = Math.floor(Math.random() * (bar.w - bar.hitW));
        bar.pos = 0;
        bar.dir = 1;
        bar.moveDir = Math.random() < 0.5 ? -1 : 1;
    }

    function startGame() {
        startScreen.style.display = 'none';
        resultScreen.style.display = 'none';
        expertPrompt.classList.add('hidden');
        endingScreen.classList.add('hidden');

        currentState = STATE.WAITING;
        dialogue = "å‡†å¤‡æˆ˜æ–—ï¼";

        audioAssets.bgm.currentTime = 0;
        audioAssets.bgm.play().catch(() => {});
    }

    function restartGame() {
        resultScreen.style.display = 'none';
        expertPrompt.classList.add('hidden');
        endingScreen.classList.add('hidden');

        player.hp = 100;
        boss.hp = 300;
        particles = [];

        shake = 0;
        flash = 0;
        shotCount = 0;
        shotTimer = 0;
        dodgeAnim = 0;
        uiSwayTimer = 0;
        boss.flashTimer = 0;
        boss.recoil = 0;

        resetZone();
        startGame();
    }

    function gotoTitle() {
        isExpertMode = false;
        player.hp = player.max;
        boss.hp = boss.max;
        particles = [];
        shake = 0;
        flash = 0;
        shotCount = 0;
        shotTimer = 0;
        dodgeAnim = 0;
        uiSwayTimer = 0;
        boss.flashTimer = 0;
        boss.recoil = 0;
        resetZone();

        if (audioAssets.bgm) {
            audioAssets.bgm.pause();
            audioAssets.bgm.currentTime = 0;
        }

        currentState = STATE.MENU;
        startScreen.style.display = 'flex';
        endingScreen.classList.add('hidden');
        resultScreen.style.display = 'none';
    }

    // ç»“ç®—æŒ‰é’®ä¸»é€»è¾‘
    function onResultPrimaryClick() {
        resultScreen.style.display = 'none';

        if (!lastResultIsWin && isExpertMode) {
            // ä¸“å®¶æ¨¡å¼å¤±è´¥ -> å†æˆ˜
            restartGame();
        } else if (lastResultIsWin) {
            // èƒœåˆ© -> è¿›å…¥ä¸åŒé€šå…³ç”»é¢
            if (isExpertMode) {
                showExpertEnding();
            } else {
                showNormalEnding();
            }
        } else {
            // æ™®é€šæ¨¡å¼å¤±è´¥
            restartGame();
        }
    }

    function onResultSecondaryClick() {
        // ä¸“å®¶å¤±è´¥ -> æ”¾å¼ƒï¼Œå›å°é¢
        resultScreen.style.display = 'none';
        expertPrompt.classList.add('hidden');
        gotoTitle();
    }

    function chooseExpert(yes) {
        // æ—§é€»è¾‘å…¼å®¹ï¼Œä¸å†ä½¿ç”¨
        isExpertMode = !!yes;
        restartGame();
    }

    // é€šå…³ç”»é¢ï¼šæ™®é€šæ¨¡å¼
    function showNormalEnding() {
        endingMode = 'normal';
        endingScreen.classList.remove('hidden');
        endingButtons.classList.add('hidden');
        endingHint.classList.add('hidden');

        endingLines.innerHTML =
            '<div class="ending-line fade-in-slow">ä½ æˆåŠŸå‡»é€€äº†å…¸ç‹±é•¿æ ¼èµ«ç½—æ–¯</div>';
    }

    // é€šå…³ç”»é¢ï¼šä¸“å®¶æ¨¡å¼
    function showExpertEnding() {
        endingMode = 'expert';
        endingScreen.classList.remove('hidden');
        endingButtons.classList.add('hidden');

        endingLines.innerHTML =
            '<div class="ending-line fade-in-slow">ç»è¿‡ä¸€ç•ªè‰°è‹¦çš„æˆ˜æ–—</div>' +
            '<div class="ending-line fade-in-slow fade-delay-1">ä½ ç»ˆäºå‡»è´¥äº†å…¸ç‹±é•¿æ ¼èµ«ç½—æ–¯</div>' +
            '<div class="ending-line fade-in-slow fade-delay-2">æˆåŠŸä»ç›‘ç‹±é€ƒç¦»</div>';

        // å…ˆéšè—æç¤ºï¼Œç­‰ä¸‰è¡Œå­—éƒ½å‡ºç°å®Œå†æ˜¾ç¤º
        endingHint.classList.add('hidden');
        setTimeout(function () {
            if (endingMode === 'expert') {
                endingHint.classList.remove('hidden');
            }
        }, 2400); // ä¸‰è¡Œä¾æ¬¡æ·¡å…¥åå†å‡ºç°æç¤º
    }

    // endingScreen ç‚¹å‡» / è§¦æ‘¸ é€»è¾‘ï¼ˆå…¼å®¹ç§»åŠ¨ç«¯ï¼‰
    function handleEndingOverlayTap(e) {
        // æŒ‰é’®è‡ªå·±çš„ç‚¹å‡»äº‹ä»¶å•ç‹¬å¤„ç†ï¼Œè¿™é‡Œåªå…³å¿ƒç©ºç™½åŒºåŸŸ / æ–‡æœ¬ç‚¹å‡»
        if (e && e.target && e.target.tagName === 'BUTTON') return;

        if (endingMode === 'normal') {
            // å†ç‚¹å‡»ä¸€æ¬¡ï¼Œæ˜¾ç¤ºä¸¤ä¸ªæŒ‰é’®
            if (endingButtons.classList.contains('hidden')) {
                endingButtons.classList.remove('hidden');
            }
        } else if (endingMode === 'expert') {
            // ä¸“å®¶æ¨¡å¼é€šå…³ï¼šç‚¹å‡»ä»»æ„ä½ç½®å›åˆ°å°é¢
            gotoTitle();
        }
    }

    endingScreen.addEventListener('click', handleEndingOverlayTap);
    endingScreen.addEventListener('touchstart', function (e) {
        // é˜²æ­¢ç§»åŠ¨ç«¯ touchstart ä¸è§¦å‘ click çš„æƒ…å†µ
        e.preventDefault();
        handleEndingOverlayTap(e);
    }, { passive: false });

    endingBtnExpert.addEventListener('click', function (e) {
        e.stopPropagation();
        endingScreen.classList.add('hidden');
        isExpertMode = true;
        restartGame();
    });

    endingBtnTitle.addEventListener('click', function (e) {
        e.stopPropagation();
        gotoTitle();
    });

    function update() {
        if (shake > 0) shake--;
        if (flash > 0) flash--;
        if (boss.flashTimer > 0) boss.flashTimer--;
        if (boss.recoil > 0) boss.recoil *= 0.8;
        if (Math.abs(boss.recoil) < 0.5) boss.recoil = 0;
        if (dodgeAnim !== 0) dodgeAnim *= 0.8;
        if (uiSwayTimer > 0) uiSwayTimer--;

        updateParticles();

        if (currentState === STATE.MENU || currentState === STATE.END) return;

        if (currentState === STATE.AIMING) {
            bar.pos += bar.speed * bar.dir;
            if (bar.pos >= bar.w) {
                bar.pos = bar.w;
                bar.dir = -1;
            }
            if (bar.pos <= 0) {
                bar.pos = 0;
                bar.dir = 1;
            }

            if (isExpertMode) {
                bar.hitStart += bar.moveDir * 0.7;
                if (bar.hitStart < 0) {
                    bar.hitStart = 0;
                    bar.moveDir = 1;
                }
                if (bar.hitStart > bar.w - bar.hitW) {
                    bar.hitStart = bar.w - bar.hitW;
                    bar.moveDir = -1;
                }
                if (Math.random() < 0.02) {
                    bar.moveDir *= -1;
                }
            }
        } else if (currentState === STATE.FIRING) {
            shotTimer--;
            if (shotTimer <= 0 && shotCount < 3) {
                if (shotCount === 0) playSfx('shoot');
                shotTimer = 8;
                fireOneShot();
                shotCount++;
            }
            if (shotCount >= 3 && shotTimer <= -25) {
                if (currentState !== STATE.END) {
                    if (boss.hp <= 0) {
                        endGame(true);
                    } else {
                        dialogue = "æ ¼èµ«ç½—æ–¯ æ­£åœ¨èšèƒ½...";
                        currentState = STATE.ENEMY;
                        frame = 1;
                    }
                }
            }
        } else if (currentState === STATE.ENEMY) {
            if (frame % 60 === 0) {
                const uiCenterY = 197;
                let roll = Math.random();

                if (!isExpertMode) {
                    if (roll < 0.15) {
                        spawnParticle('player_dodge', "é—ªé¿!", NES_W - 40, NES_H - 35, '#0ff');
                        dialogue = "æ®‹å½±ç¬ç§»ï¼";
                        dodgeAnim = 30;
                    } else if (roll < 0.20) {
                        spawnParticle('player_miss', "MISS", NES_W - 40, NES_H - 35, '#0f0');
                        dialogue = "æ”»å‡»åç¦»ï¼";
                        uiSwayTimer = 60;
                    } else if (roll < 0.30) {
                        const dmg = 9999999;
                        player.hp -= dmg;
                        if (player.hp < 0) player.hp = 0;

                        spawnDeathBoom(NES_W / 2, uiCenterY);
                        shake = 50;
                        flash = 40;
                        flashColor = '#f00';
                        spawnParticle('mega_text', "-9999999", NES_W - 90, NES_H - 30, '#f00');
                        dialogue = "ç»æœ›é™ä¸´ï¼ï¼ï¼";
                        playSfx('kill');

                        endGame(false);
                        return;
                    } else {
                        const dmg = 34;
                        player.hp -= dmg;
                        if (player.hp < 0) player.hp = 0;

                        spawnPixelExplosion(NES_W / 2, uiCenterY);
                        shake = 25;
                        flash = 12;
                        flashColor = '#f00';
                        spawnParticle('player_hurt', "-" + dmg, NES_W - 40, NES_H - 35, '#ff3333');
                        dialogue = "è£…ç”²ä¸¥é‡å—æŸï¼";
                        playSfx('hit');

                        if (player.hp <= 0) {
                            endGame(false);
                            return;
                        }
                    }
                } else {
                    if (roll < 0.15) {
                        spawnParticle('player_dodge', "é—ªé¿!", NES_W - 40, NES_H - 35, '#0ff');
                        dialogue = "æ®‹å½±ç¬ç§»ï¼";
                        dodgeAnim = 30;
                    } else if (roll < 0.33) {
                        const dmg = 9999999;
                        player.hp -= dmg;
                        if (player.hp < 0) player.hp = 0;

                        spawnDeathBoom(NES_W / 2, uiCenterY);
                        shake = 50;
                        flash = 40;
                        flashColor = '#f00';
                        spawnParticle('mega_text', "-9999999", NES_W - 90, NES_H - 30, '#f00');
                        dialogue = "ç»æœ›é™ä¸´ï¼ï¼ï¼";
                        playSfx('kill');

                        endGame(false);
                        return;
                    } else {
                        const dmg = 34;
                        player.hp -= dmg;
                        if (player.hp < 0) player.hp = 0;

                        spawnPixelExplosion(NES_W / 2, uiCenterY);
                        shake = 25;
                        flash = 12;
                        flashColor = '#f00';
                        spawnParticle('player_hurt', "-" + dmg, NES_W - 40, NES_H - 35, '#ff3333');
                        dialogue = "è£…ç”²ä¸¥é‡å—æŸï¼";
                        playSfx('hit');

                        if (player.hp <= 0) {
                            endGame(false);
                            return;
                        }
                    }
                }

                if (player.hp > 0) {
                    currentState = STATE.WAITING;
                    setTimeout(() => {
                        if (currentState !== STATE.END) {
                            dialogue = "è¶ç°åœ¨ï¼Œåå‡»ï¼";
                            resetZone();
                        }
                    }, 600);
                }
            }
        }
    }

    function fireOneShot() {
        if (currentState === STATE.END) return;

        const spread = 40;
        const tx = NES_W / 2 + (Math.random() - 0.5) * spread;
        const ty = 90 + (Math.random() - 0.5) * spread;

        spawnParticle('crosshair', null, tx, ty);

        if (isHit) {
            let baseDmg = isCrit ? 60 : 35;
            let dmg = baseDmg + Math.floor(Math.random() * 6 - 3);

            boss.hp -= dmg;
            if (boss.hp < 0) boss.hp = 0;
            boss.flashTimer = 5;

            if (isCrit) {
                spawnParticle('text', "æš´å‡» " + dmg, tx, ty, '#0ff');
                shake = 15;
                boss.recoil = 15;
                flash = 5;
                flashColor = '#eee';
                spawnHitSparks(tx, ty, 10, '#0ff');
            } else {
                spawnParticle('text', "-" + dmg, tx, ty, '#fff');
                shake = 8;
                boss.recoil = 5;
                spawnHitSparks(tx, ty, 5, '#fd0');
            }

            playSfx('hit');

            if (boss.hp <= 0) {
                endGame(true);
            }
        } else {
            spawnParticle('text', "MISS", tx, ty, '#888');
        }
    }

    function endGame(isWin) {
        if (currentState === STATE.END) return;
        currentState = STATE.END;
        lastResultIsWin = isWin;

        if (audioAssets.bgm) audioAssets.bgm.pause();

        setTimeout(() => {
            showResult(isWin);
        }, 1000);
    }

    function spawnParticle(type, text, x, y, color) {
        let p = {
            type: type,
            life: 30,
            maxLife: 30,
            x: x,
            y: y,
            text: text,
            color: color || '#fff',
            radius: 10,
            vx: 0,
            vy: 0
        };
        if (type === 'mega_text') {
            p.life = 60;
            p.maxLife = 60;
        }
        if (type === 'player_miss' || type === 'player_dodge' || type === 'player_hurt') {
            p.life = 50;
            p.maxLife = 50;
        }
        particles.push(p);
    }

    function spawnHitSparks(x, y, count, color) {
        for (let i = 0; i < count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 2 + Math.random() * 4;
            particles.push({
                type: 'spark',
                life: 20,
                maxLife: 20,
                x: x,
                y: y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                color: color
            });
        }
    }

    function spawnPixelExplosion(x, y) {
        particles.push({
            type: 'nes_boom',
            x: x,
            y: y,
            life: 12,
            maxLife: 12,
            scale: 1,
            color: '#fff'
        });
    }

    function spawnDeathBoom(x, y) {
        particles.push({type: 'nes_boom', x: x, y: y, life: 20, maxLife: 20, scale: 3, color: '#f00'});
        particles.push({type: 'nes_boom', x: x - 20, y: y + 20, life: 25, maxLife: 25, scale: 2, color: '#000'});
        particles.push({type: 'nes_boom', x: x + 20, y: y - 20, life: 25, maxLife: 25, scale: 2, color: '#500'});
    }

    function updateParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.life--;

            if (p.type === 'text') p.y -= 0.5;
            if (p.type === 'mega_text') {
                p.x += (Math.random() - 0.5) * 4;
                p.y += (Math.random() - 0.5) * 4;
            }
            if (p.type === 'player_miss' || p.type === 'player_dodge' || p.type === 'player_hurt') {
                p.y -= 0.3;
            }
            if (p.type === 'spark') {
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.2;
            }

            if (p.life <= 0) {
                particles.splice(i, 1);
            }
        }
    }

    function drawParticles() {
        particles.forEach(p => {
            ctx.font = "12px 'DotGothic16', sans-serif";
            if (p.type === 'text') {
                ctx.save();
                ctx.fillStyle = p.color;
                ctx.textAlign = "center";
                ctx.strokeStyle = "#000";
                ctx.lineWidth = 2;
                ctx.strokeText(p.text, p.x, p.y);
                ctx.fillText(p.text, p.x, p.y);
                ctx.restore();
            } else if (p.type === 'mega_text') {
                ctx.save();
                ctx.fillStyle = p.color;
                ctx.font = "28px 'DotGothic16', sans-serif";
                ctx.textAlign = "center";
                ctx.shadowColor = "#f00";
                ctx.shadowBlur = 10;
                ctx.strokeStyle = "#fff";
                ctx.lineWidth = 3;
                ctx.strokeText(p.text, p.x, p.y);
                ctx.fillText(p.text, p.x, p.y);
                ctx.restore();
            } else if (p.type === 'player_miss' || p.type === 'player_dodge') {
                ctx.save();
                ctx.fillStyle = p.color;
                ctx.font = "16px 'DotGothic16', sans-serif";
                ctx.textAlign = "center";
                ctx.strokeStyle = "#000";
                ctx.lineWidth = 2;
                ctx.strokeText(p.text, p.x, p.y);
                ctx.fillText(p.text, p.x, p.y);
                ctx.restore();
            } else if (p.type === 'player_hurt') {
                ctx.save();
                ctx.fillStyle = p.color;
                ctx.font = "20px 'DotGothic16', sans-serif";
                ctx.textAlign = "center";
                ctx.shadowColor = "#000";
                ctx.shadowBlur = 2;
                ctx.strokeText(p.text, p.x, p.y);
                ctx.fillText(p.text, p.x, p.y);
                ctx.restore();
            } else if (p.type === 'crosshair') {
                ctx.save();
                ctx.strokeStyle = "#fff";
                ctx.lineWidth = 2;
                const r = 8;
                const ext = 4;
                ctx.beginPath();
                ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(p.x - r - ext, p.y);
                ctx.lineTo(p.x + r + ext, p.y);
                ctx.moveTo(p.x, p.y - r - ext);
                ctx.lineTo(p.x, p.y + r + ext);
                ctx.stroke();

                ctx.fillStyle = "red";
                ctx.fillRect(p.x - 1, p.y - 1, 2, 2);
                ctx.restore();
            } else if (p.type === 'spark') {
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, 2, 2);
            } else if (p.type === 'nes_boom') {
                let progress = p.life / p.maxLife;
                let stage = 0;
                if (progress > 0.66) stage = 1;
                else if (progress > 0.33) stage = 2;
                else stage = 3;
                drawNESBoomShape(ctx, p.x, p.y, stage, p.scale, p.color);
            }
        });
    }

    function drawNESBoomShape(ctx, x, y, stage, scale, color) {
        ctx.save();
        ctx.translate(x, y);
        ctx.scale(scale, scale);
        ctx.translate(-x, -y);
        ctx.fillStyle = color || "#FFFFFF";

        if (stage === 1) {
            ctx.fillRect(x - 4, y - 4, 8, 8);
            ctx.fillRect(x - 12, y - 2, 24, 4);
            ctx.fillRect(x - 2, y - 12, 4, 24);
            ctx.fillRect(x - 8, y - 8, 4, 4);
            ctx.fillRect(x + 4, y - 8, 4, 4);
            ctx.fillRect(x - 8, y + 4, 4, 4);
            ctx.fillRect(x + 4, y + 4, 4, 4);
        } else if (stage === 2) {
            ctx.fillRect(x - 10, y - 10, 20, 20);
            ctx.clearRect(x - 4, y - 4, 8, 8);
            ctx.fillRect(x - 14, y - 6, 4, 12);
            ctx.fillRect(x + 10, y - 6, 4, 12);
            ctx.fillRect(x - 6, y - 14, 12, 4);
            ctx.fillRect(x - 6, y + 10, 12, 4);
        } else if (stage === 3) {
            ctx.fillRect(x - 14, y - 14, 8, 8);
            ctx.fillRect(x + 6, y - 14, 8, 8);
            ctx.fillRect(x - 14, y + 6, 8, 8);
            ctx.fillRect(x + 6, y + 6, 8, 8);
            ctx.fillRect(x - 6, y - 6, 12, 12);
        }
        ctx.restore();
    }

    function showResult(isWin) {
        resultScreen.style.display = 'none';
        resultScreen.offsetHeight;
        resultScreen.style.display = 'flex';

        const titleDiv = resultTitle;
        const descDiv = resultDesc;

        if (isWin) {
            if (player.hp === 100) titleDiv.innerText = "å®Œç¾æ— ç‘•çš„èƒœåˆ©";
            else titleDiv.innerText = "å¥‡è¿¹èˆ¬çš„èƒœåˆ©";
            titleDiv.className = "result-title win-title";

            let rank = "B";
            if (player.hp === 100) rank = "S+";
            else if (player.hp >= 66) rank = "S";
            else if (player.hp >= 32) rank = "A+";

            descDiv.innerHTML =
                `å‰©ä½™ç”Ÿå‘½: ${player.hp}%<br>` +
                `ä½ å‡»è´¥äº†å…¸ç‹±é•¿æ ¼èµ«ç½—æ–¯<br>` +
                `è¯„ä»·: <span style="color:#ff0; font-size:20px;">${rank}</span>`;
        } else {
            titleDiv.innerText = isExpertMode ? "æ— æƒ…çš„ç¢¾å‹" : "å½»åº•çš„ç»æœ›";
            titleDiv.className = "result-title lose-title";
            descDiv.innerHTML =
                `BOSS å‰©ä½™è¡€é‡: ${boss.hp}<br>` +
                `${isExpertMode ? 'æ ¼èµ«ç½—æ–¯å‡»è´¥äº†ä½ ' : 'å…¸ç‹±é•¿æ ¼èµ«ç½—æ–¯å‡»è´¥äº†ä½ '}`;
        }

        if (isWin) {
            btnPrimary.textContent = "ä»»åŠ¡å®Œæˆ";
            btnSecondary.classList.add("hidden");
        } else if (!isWin && isExpertMode) {
            btnPrimary.textContent = "å†æˆ˜";
            btnSecondary.textContent = "æ”¾å¼ƒ";
            btnSecondary.classList.remove("hidden");
        } else {
            btnPrimary.textContent = "å†æ¬¡å°è¯•";
            btnSecondary.classList.add("hidden");
        }
    }

    function draw() {
        let renderX = 0;
        if (dodgeAnim !== 0) renderX = dodgeAnim;

        if (flash > 0 && Math.floor(frame / 2) % 2 === 0) ctx.fillStyle = flashColor;
        else ctx.fillStyle = '#050505';
        ctx.fillRect(0, 0, NES_W, NES_H);

        let dx = 0, dy = 0;
        if (shake > 0) {
            dx = (Math.random() - 0.5) * shake;
            dy = (Math.random() - 0.5) * shake;
        }

        ctx.save();
        if (Math.abs(dodgeAnim) > 1) {
            ctx.save();
            ctx.translate(dx - dodgeAnim * 0.5, dy);
            ctx.globalAlpha = 0.5;
            ctx.globalCompositeOperation = "lighter";
            drawUIContent();
            ctx.restore();
        }
        ctx.translate(dx + renderX, dy);
        drawUIContent();
        drawParticles();
        ctx.restore();
    }

    function drawUIContent() {
        ctx.font = "12px 'DotGothic16', sans-serif";
        ctx.fillStyle = "#666";
        ctx.textAlign = "center";

        const bossNameFull = isExpertMode ? "å…¸ç‹±é•¿æ ¼èµ«ç½—æ–¯EX" : "å…¸ç‹±é•¿æ ¼èµ«ç½—æ–¯";
        ctx.fillText(bossNameFull, NES_W / 2, 10);

        const bossTitle = bossNameFull;
        const metrics = ctx.measureText(bossTitle);
        const barWTop = metrics.width + 10;
        drawBar(NES_W / 2 - barWTop / 2, 22, barWTop, 6, boss.hp, boss.max, '#d00');

        ctx.fillStyle = isExpertMode ? "#ff6666" : "#ffffff";
        ctx.beginPath();
        ctx.ellipse(NES_W / 2, 125, 42, 10, 0, 0, Math.PI * 2);
        ctx.fill();

        if (isImageLoaded) {
            let bx = (Math.random() - 0.5) * boss.recoil;
            let by = (Math.random() - 0.5) * boss.recoil;
            ctx.save();
            ctx.translate(bx, by);
            if (boss.flashTimer > 0) {
                ctx.filter = "brightness(500%)";
                drawBossImage();
                ctx.filter = "none";
            } else {
                drawBossImage();
            }
            ctx.restore();
        } else {
            ctx.fillStyle = "#a00";
            ctx.fillRect(NES_W / 2 - 20, 45, 40, 80);
        }

        const boxH = 65;
        const boxY = NES_H - boxH - 10;
        let swayX = 0;
        if (uiSwayTimer > 0) {
            swayX = Math.sin(frame * 0.1) * 10 * (uiSwayTimer / 60);
        }

        ctx.save();
        ctx.translate(swayX, 0);

        ctx.fillStyle = "#000";
        ctx.fillRect(10, boxY, NES_W - 20, boxH);
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 2;
        ctx.strokeRect(10, boxY, NES_W - 20, boxH);

        let isPlayerTurn =
            currentState === STATE.WAITING ||
            currentState === STATE.AIMING ||
            currentState === STATE.FIRING;
        let isBossTurn = currentState === STATE.ENEMY;

        if (isBossTurn) {
            ctx.fillStyle = "#000";
            ctx.fillRect(10, boxY - 16, 80, 16);
            ctx.strokeStyle = "#fff";
            ctx.strokeRect(10, boxY - 16, 80, 16);
            ctx.fillStyle = "#fff";
            ctx.textAlign = "center";
            const bossTagName = isExpertMode ? "æ ¼èµ«ç½—æ–¯EX" : "æ ¼èµ«ç½—æ–¯";
            ctx.fillText(bossTagName, 10 + 40, boxY - 3);
        }
        if (isPlayerTurn) {
            ctx.fillStyle = "#000";
            ctx.fillRect(NES_W - 10 - 36, boxY - 16, 36, 16);
            ctx.strokeStyle = "#fff";
            ctx.strokeRect(NES_W - 10 - 36, boxY - 16, 36, 16);
            ctx.fillStyle = "#fff";
            ctx.textAlign = "center";
            ctx.fillText("ç©å®¶", NES_W - 10 - 18, boxY - 3);
        }

        ctx.textAlign = "right";
        let hpColor = player.hp > 35 ? '#0f0' : '#f00';
        drawBar(NES_W - 60, boxY + 10, 40, 6, player.hp, player.max, hpColor);
        ctx.fillStyle = "#fff";
        ctx.fillText("HP", NES_W - 65, boxY + 16);

        ctx.fillStyle = "#fff";
        ctx.textAlign = "left";
        ctx.fillText(dialogue, 20, boxY + 25);

        if (currentState !== STATE.ENEMY && currentState !== STATE.END) {
            const bx = (NES_W - bar.w) / 2;
            const by = boxY + 45;

            ctx.fillStyle = "#000";
            ctx.fillRect(bx, by, bar.w, bar.h);
            ctx.strokeStyle = "#666";
            ctx.lineWidth = 1;
            ctx.strokeRect(bx, by, bar.w, bar.h);

            const hitCenterX = bx + bar.hitStart + bar.hitW / 2;
            const hitCenterY = by + bar.h / 2;

            ctx.save();
            ctx.translate(hitCenterX, hitCenterY);
            ctx.strokeStyle = "#fff";
            ctx.lineWidth = 1.5;

            ctx.beginPath();
            ctx.arc(0, -6, 3, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, -3);
            ctx.lineTo(0, 4);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, -1);
            ctx.lineTo(-4, 2);
            ctx.moveTo(0, -1);
            ctx.lineTo(4, 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, 4);
            ctx.lineTo(-3, 8);
            ctx.moveTo(0, 4);
            ctx.lineTo(3, 8);
            ctx.stroke();

            ctx.restore();

            let drawPos = bar.pos;
            if (drawPos < 0) drawPos = 0;
            if (drawPos > bar.w) drawPos = bar.w;

            const cursorX = bx + drawPos;
            const cursorY = hitCenterY;

            ctx.save();
            ctx.translate(cursorX, cursorY);
            ctx.strokeStyle = "#f00";
            ctx.lineWidth = 1.5;

            const r = 4;
            const ext = 3;

            ctx.beginPath();
            ctx.arc(0, 0, r, 0, Math.PI * 2);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(-r - ext, 0);
            ctx.lineTo(-2, 0);
            ctx.moveTo(2, 0);
            ctx.lineTo(r + ext, 0);
            ctx.moveTo(0, -r - ext);
            ctx.lineTo(0, -2);
            ctx.moveTo(0, 2);
            ctx.lineTo(0, r + ext);
            ctx.stroke();

            ctx.fillStyle = "#f00";
            ctx.fillRect(-1, -1, 2, 2);

            ctx.restore();
        }

        ctx.restore();
    }

    function drawBossImage() {
        const maxH = 85;
        const ratio = bossImg.width / bossImg.height;
        const drawH = maxH;
        const drawW = maxH * ratio;
        const x = (NES_W - drawW) / 2;
        const y = 45;

        const centerX = NES_W / 2;
        const centerY = y + drawH / 2;

        ctx.save();

        if (isExpertMode) {
            ctx.save();
            const radius = drawW * 0.8;
            const pulse = 0.2 * Math.sin(frame * 0.08);
            const gradient = ctx.createRadialGradient(
                centerX, centerY, 8,
                centerX, centerY, radius
            );
            gradient.addColorStop(0, `rgba(255,80,80,${0.6 + pulse})`);
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.globalAlpha = 0.7;
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            ctx.shadowColor = "#ff4444";
            ctx.shadowBlur = 18;
        }

        ctx.drawImage(bossImg, x, y, drawW, drawH);
        ctx.restore();
    }

    function drawBar(x, y, w, h, val, max, color) {
        ctx.fillStyle = "#222";
        ctx.fillRect(x, y, w, h);
        ctx.fillStyle = color;
        const wFill = Math.max(0, (val / max) * w);
        ctx.fillRect(x, y, wFill, h);
    }

    function handleInput(e) {
        if (e.target.tagName === 'BUTTON') return;
        if (e.target.id === 'manualLoader') return;
        e.preventDefault();

        if (currentState === STATE.MENU) {
            startGame();
            return;
        }

        if (currentState === STATE.WAITING) {
            currentState = STATE.AIMING;
        } else if (currentState === STATE.AIMING) {
            let hitL = bar.hitStart;
            let hitR = bar.hitStart + bar.hitW;
            const center = hitL + bar.hitW / 2;
            if (bar.pos >= hitL && bar.pos <= hitR) {
                isHit = true;
                isCrit = (Math.abs(bar.pos - center) < bar.hitW * 0.25);
            } else {
                isHit = false;
                isCrit = false;
            }
            currentState = STATE.FIRING;
            shotCount = 0;
            shotTimer = 0;
        }
    }

    function loop(timestamp) {
        requestAnimationFrame(loop);
        if (!lastTime) lastTime = timestamp;
        const elapsed = timestamp - lastTime;
        if (elapsed > interval) {
            lastTime = timestamp - (elapsed % interval);
            frame++;
            update();
            draw();
        }
    }

    window.addEventListener('mousedown', handleInput);
    window.addEventListener('touchstart', handleInput, {passive: false});
    startScreen.addEventListener('mousedown', handleInput);
    startScreen.addEventListener('touchstart', handleInput);
</script>
</body>
</html>
