<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å…¸ç‹±é•¿æ ¼èµ«ç½—æ–¯ - Beta 0.5.8</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=DotGothic16&display=swap" rel="stylesheet">

    <style>
        body {
            margin: 0; padding: 0;
            background-color: #050505;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            font-family: 'DotGothic16', 'Courier New', monospace; 
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            max-width: 600px; 
            aspect-ratio: 256/240;
            background: #000;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated; 
        }

        /* ç•Œé¢è¦†ç›–å±‚é€šç”¨æ ·å¼ */
        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: #fff; text-align: center;
            pointer-events: auto;
        }

        /* å¯åŠ¨å°é¢ï¼šçº¯é»‘èƒŒæ™¯ */
        #startScreen {
            background: #000000; /* ä¿®æ­£ï¼šå…¨é»‘ */
            z-index: 60;
        }
        
        /* ç»“ç®—ç•Œé¢ï¼šå¸¦æ·¡å…¥åŠ¨ç”» */
        #resultScreen {
            background: rgba(0,0,0,0.9);
            display: none; 
            z-index: 70;
            /* ä¿®æ­£ï¼šç¡®ä¿åŠ¨ç”»ç”Ÿæ•ˆ */
            animation: fadeIn 0.5s ease-in forwards;
        }
        
        /* ç®€å•çš„æ·¡å…¥åŠ¨ç”» */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        /* æ–‡ä»¶ä¸Šä¼ æç¤º */
        #fileInputOverlay {
            background: rgba(0,0,0,0.95);
            display: none;
            z-index: 80;
        }

        .blink { animation: blinker 1s linear infinite; }
        @keyframes blinker { 50% { opacity: 0; } }

        .result-title { font-size: 40px; font-weight: bold; margin-bottom: 10px; text-shadow: 4px 4px #000; }
        .result-desc { font-size: 16px; color: #ccc; line-height: 1.8; }
        .win-title { color: #0f0; }
        .lose-title { color: #f00; }
        
        .btn {
            border: 2px solid #fff; background: #222; color: #fff;
            padding: 12px 24px; font-size: 18px; margin-top: 20px; 
            font-family: inherit; cursor: pointer;
            image-rendering: pixelated;
        }

        /* éšè—å…ƒç´  */
        .hidden { display: none !important; }
    </style>
</head>
<body>

<div id="gameContainer">
    <canvas id="gameCanvas"></canvas>

    <!-- å¯åŠ¨å°é¢ -->
    <div id="startScreen" class="overlay">
        <div class="result-title" style="margin-bottom: 50px;">å…¸ç‹±é•¿æ ¼èµ«ç½—æ–¯</div>
        <!-- å°å­—å·²åˆ é™¤ -->
        <div id="pressStartBtn" class="blink" style="font-size: 24px; color: #ff0;">â–¶ ç‚¹å‡»å±å¹•å¼€å§‹</div>
    </div>

    <!-- ç»“ç®—ç•Œé¢ -->
    <div id="resultScreen" class="overlay">
        <div id="resultTitle" class="result-title"></div>
        <div id="resultDesc" class="result-desc"></div>
        <button class="btn" onclick="restartGame()">å†æ¬¡å°è¯•</button>
    </div>

    <!-- å¤‡ç”¨ä¸Šä¼  -->
    <div id="fileInputOverlay" class="overlay">
        <p style="font-size: 20px; margin-bottom: 20px;">æœªæ£€æµ‹åˆ° boss.png</p>
        <button class="btn" onclick="document.getElementById('manualLoader').click()">ğŸ“‚ è½½å…¥å›¾åƒ</button>
        <input type="file" id="manualLoader" accept="image/*" style="display:none" onchange="handleManualLoad(this)">
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    const startScreen = document.getElementById('startScreen');
    const resultScreen = document.getElementById('resultScreen');
    const fileOverlay = document.getElementById('fileInputOverlay');
    const resultTitle = document.getElementById('resultTitle');
    const resultDesc = document.getElementById('resultDesc');

    const NES_W = 256;
    const NES_H = 240;
    canvas.width = NES_W;
    canvas.height = NES_H;

    // --- èµ„æºåŠ è½½ ---
    const bossImg = new Image();
    let isImageLoaded = false;
    
    // å›¾ç‰‡åŠ è½½é€»è¾‘
    bossImg.onload = function() { isImageLoaded = true; };
    bossImg.onerror = function() { console.log("Image failed"); }; // å¤±è´¥ä¹Ÿä¸é˜»å¡ï¼Œåªæ˜¯æ²¡å›¾
    bossImg.src = 'boss.png'; 

    // éŸ³é¢‘ç³»ç»Ÿ
    const audioAssets = {
        bgm: new Audio('bgm.mp3'),
        shoot: new Audio('player_shoot.mp3'),
        hit: new Audio('boss_hit.mp3'),
        kill: new Audio('boss_kill.mp3')
    };
    audioAssets.bgm.loop = true; audioAssets.bgm.volume = 1.0;

    function playSfx(name) {
        try {
            const original = audioAssets[name];
            if (original) {
                const clone = original.cloneNode();
                clone.volume = 0.4; 
                clone.play().catch(e => {});
            }
        } catch(e) { console.log("Audio Error:", e); }
    }

    function handleManualLoad(input) {
        if (input.files && input.files[0]) {
            const reader = new FileReader();
            reader.onload = function(e) { 
                bossImg.src = e.target.result; 
                fileOverlay.style.display = 'none';
            }
            reader.readAsDataURL(input.files[0]);
        }
    }

    // --- æ¸¸æˆçŠ¶æ€ ---
    const STATE = { MENU: 0, WAITING: 1, AIMING: 2, FIRING: 3, ENEMY: 4, END: 5 };
    let currentState = STATE.MENU; 
    let frame = 0;
    
    let player = { hp: 100, max: 100 };
    let boss = { hp: 300, max: 300, flashTimer: 0, recoil: 0 }; 
    
    let dialogue = "è­¦å‘Šï¼šå‰æ–¹é«˜èƒ½ååº”ï¼";
    
    // ä¿®æ­£ï¼šé€Ÿåº¦è°ƒå› 11
    let bar = { w: 180, h: 14, y: 175, pos: 0, speed: 11, dir: 1, hitStart: 0, hitW: 16 };
    
    let shotCount = 0;
    let shotTimer = 0;
    let isCrit = false;
    let isHit = false;

    let particles = [];
    let shake = 0;
    let flash = 0;
    let flashColor = '#eee';
    let dodgeAnim = 0;
    let uiSwayTimer = 0; 

    // FPS é”å®š
    let lastTime = 0;
    const FPS = 60;
    const interval = 1000 / FPS;

    // å¯åŠ¨
    resetZone();
    loop(0);

    function resetZone() {
        bar.hitStart = Math.floor(Math.random() * (bar.w - bar.hitW));
        bar.pos = 0;
        bar.dir = 1;
    }

    function startGame() {
        startScreen.style.display = 'none';
        // å¼ºåˆ¶é‡ç½®ç»“ç®—ç”»é¢æ˜¾ç¤ºï¼Œä»¥ä¾¿ä¸‹æ¬¡fadeInèƒ½è§¦å‘
        resultScreen.style.display = 'none'; 
        
        // å¦‚æœå›¾ç‰‡è¿˜æ˜¯æ²¡å¥½ï¼ˆä¸”ä¸æ˜¯æ‰‹åŠ¨åŠ è½½æ¨¡å¼ï¼‰ï¼Œæ˜¾ç¤ºæç¤º
        if (!isImageLoaded && bossImg.src.endsWith('boss.png')) {
             // æ£€æŸ¥æ˜¯å¦çœŸçš„æ˜¯åŠ è½½å¤±è´¥ï¼Œè¿™é‡Œä¸ºäº†ç¨³å¥ï¼Œå¦‚æœè¿˜æ²¡å¥½å°±è®©å®ƒå»
             if (bossImg.naturalWidth === 0) {
                 // è¿™é‡Œå¯ä»¥æ˜¾ç¤ºæ‰‹åŠ¨ä¸Šä¼ ï¼Œä½†ä¸ºäº†ä¸æ‰“æ–­æµç¨‹ï¼Œæˆ‘ä»¬ç›´æ¥å¼€å§‹ï¼Œæ¸¸æˆé‡Œä¼šæ˜¾ç¤ºçº¢å—
                 // å¦‚æœç”¨æˆ·éœ€è¦æ‰‹åŠ¨ä¸Šä¼ ï¼Œå¯ä»¥åœ¨çº¢å—å‡ºç°ååˆ·æ–°é¡µé¢
             }
        }

        currentState = STATE.WAITING;
        audioAssets.bgm.currentTime = 0;
        audioAssets.bgm.play().catch(e=>{});
    }

    function restartGame() {
        player.hp = 100;
        boss.hp = 300;
        particles = [];
        
        shake = 0; flash = 0;
        shotCount = 0; shotTimer = 0;
        dodgeAnim = 0; uiSwayTimer = 0;
        boss.flashTimer = 0; boss.recoil = 0;
        
        dialogue = "é‡æ–°æ¥æ•Œï¼Œä¿æŒè­¦æƒ•ï¼";
        
        startGame();
    }

    // --- é€»è¾‘ ---
    function update() {
        if (shake > 0) shake--;
        if (flash > 0) flash--;
        if (boss.flashTimer > 0) boss.flashTimer--;
        if (boss.recoil > 0) boss.recoil *= 0.8;
        if (Math.abs(boss.recoil) < 0.5) boss.recoil = 0;
        if (dodgeAnim !== 0) dodgeAnim *= 0.8;
        if (uiSwayTimer > 0) uiSwayTimer--;

        updateParticles();

        if (currentState === STATE.MENU || currentState === STATE.END) return;

        if (currentState === STATE.AIMING) {
            bar.pos += bar.speed * bar.dir;
            if (bar.pos >= bar.w || bar.pos <= 0) bar.dir *= -1;
        }
        else if (currentState === STATE.FIRING) {
            shotTimer--;
            if (shotTimer <= 0 && shotCount < 3) {
                if (shotCount === 0) playSfx('shoot');
                shotTimer = 8; 
                fireOneShot();
                shotCount++;
            }
            if (shotCount >= 3 && shotTimer <= -25) {
                if (currentState !== STATE.END) {
                    if (boss.hp <= 0) {
                        endGame(true);
                    } else {
                        dialogue = "æ ¼èµ«ç½—æ–¯ æ­£åœ¨èšèƒ½...";
                        currentState = STATE.ENEMY;
                        frame = 1;
                    }
                }
            }
        }
        else if (currentState === STATE.ENEMY) {
            if (frame % 60 === 0) {
                const uiCenterY = 197;
                let roll = Math.random(); 

                if (roll < 0.15) {
                    spawnParticle('player_dodge', "é—ªé¿!", NES_W - 40, NES_H - 35, '#0ff');
                    dialogue = "æ®‹å½±ç¬ç§»ï¼";
                    dodgeAnim = 30; 
                }
                else if (roll < 0.20) {
                    spawnParticle('player_miss', "MISS", NES_W - 40, NES_H - 35, '#0f0');
                    dialogue = "æ”»å‡»åç¦»ï¼";
                    uiSwayTimer = 60; 
                }
                else if (roll < 0.30) {
                    const dmg = 9999999;
                    player.hp -= dmg;
                    if (player.hp < 0) player.hp = 0;

                    spawnDeathBoom(NES_W/2, uiCenterY);
                    shake = 50; flash = 40; flashColor = '#f00';
                    spawnParticle('mega_text', "-9999999", NES_W - 90, NES_H - 30, '#f00');
                    dialogue = "ç»æœ›é™ä¸´ï¼ï¼ï¼";
                    playSfx('kill');
                    
                    endGame(false);
                    return;
                }
                else {
                    const dmg = 34; 
                    player.hp -= dmg;
                    if (player.hp < 0) player.hp = 0;

                    spawnPixelExplosion(NES_W/2, uiCenterY);
                    shake = 25; flash = 12; flashColor = '#f00';
                    spawnParticle('player_hurt', "-" + dmg, NES_W - 40, NES_H - 35, '#ff3333');
                    dialogue = "è£…ç”²ä¸¥é‡å—æŸï¼";
                    playSfx('hit');

                    if (player.hp <= 0) {
                        endGame(false);
                        return; 
                    }
                }

                if (player.hp > 0) {
                    currentState = STATE.WAITING;
                    setTimeout(() => {
                        if (currentState !== STATE.END) {
                            dialogue = "è¶ç°åœ¨ï¼Œåå‡»ï¼";
                            resetZone();
                        }
                    }, 600);
                }
            }
        }
    }

    function fireOneShot() {
        if (currentState === STATE.END) return; 

        const spread = 40;
        const tx = NES_W/2 + (Math.random() - 0.5) * spread;
        const ty = 90 + (Math.random() - 0.5) * spread;

        spawnParticle('crosshair', null, tx, ty);

        if (isHit) {
            let baseDmg = isCrit ? 60 : 35; 
            let dmg = baseDmg + Math.floor(Math.random() * 6 - 3);
            
            boss.hp -= dmg;
            if (boss.hp < 0) boss.hp = 0;
            boss.flashTimer = 5;
            
            if (isCrit) {
                spawnParticle('text', "æš´å‡» " + dmg, tx, ty, '#0ff');
                shake = 15; boss.recoil = 15; flash = 5; flashColor = '#eee';
                spawnHitSparks(tx, ty, 10, '#0ff');
            } else {
                spawnParticle('text', "-" + dmg, tx, ty, '#fff');
                shake = 8; boss.recoil = 5; 
                spawnHitSparks(tx, ty, 5, '#fd0');
            }
            
            playSfx('hit');

            if (boss.hp <= 0) {
                endGame(true);
            }

        } else {
            spawnParticle('text', "MISS", tx, ty, '#888');
        }
    }

    function endGame(isWin) {
        if (currentState === STATE.END) return;
        currentState = STATE.END;
        
        if(audioAssets.bgm) audioAssets.bgm.pause();

        setTimeout(() => {
            showResult(isWin);
        }, 1000);
    }

    function spawnParticle(type, text, x, y, color) {
        let p = { type: type, life: 30, maxLife:30, x: x, y: y, text: text, color: color || '#fff', radius: 10, vx: 0, vy: 0 };
        if (type === 'mega_text') { p.life = 60; p.maxLife = 60; }
        if (type === 'player_miss' || type === 'player_dodge' || type === 'player_hurt') { p.life = 50; p.maxLife = 50; }
        particles.push(p);
    }
    function spawnHitSparks(x, y, count, color) {
        for(let i=0; i<count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 2 + Math.random() * 4;
            particles.push({ type: 'spark', life: 20, x: x, y: y, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed, color: color });
        }
    }
    function spawnPixelExplosion(x, y) { particles.push({ type: 'nes_boom', x: x, y: y, life: 12, maxLife: 12, scale: 1, color: '#fff' }); }
    function spawnDeathBoom(x, y) {
        particles.push({ type: 'nes_boom', x: x, y: y, life: 20, maxLife: 20, scale: 3, color: '#f00' });
        particles.push({ type: 'nes_boom', x: x-20, y: y+20, life: 25, maxLife: 25, scale: 2, color: '#000' });
        particles.push({ type: 'nes_boom', x: x+20, y: y-20, life: 25, maxLife: 25, scale: 2, color: '#500' });
    }
    function updateParticles() {
        for(let i=particles.length-1; i>=0; i--) {
            let p = particles[i];
            p.life--;
            if (p.type === 'text') p.y -= 0.5;
            if (p.type === 'mega_text') { p.x += (Math.random()-0.5)*4; p.y += (Math.random()-0.5)*4; }
            if (p.type === 'player_miss' || p.type === 'player_dodge' || p.type === 'player_hurt') p.y -= 0.3;
            if (p.type === 'spark') { p.x += p.vx; p.y += p.vy; p.vy += 0.2; }
            if (p.life <= 0) particles.splice(i, 1);
        }
    }
    function drawParticles() {
        particles.forEach(p => {
            // ç»Ÿä¸€è®¾ç½®å­—ä½“
            ctx.font = "12px 'DotGothic16', sans-serif"; 
            if (p.type === 'text') {
                ctx.save(); ctx.fillStyle = p.color; ctx.textAlign = "center"; ctx.strokeStyle = "#000"; ctx.lineWidth = 2;
                ctx.strokeText(p.text, p.x, p.y); ctx.fillText(p.text, p.x, p.y); ctx.restore();
            } 
            else if (p.type === 'mega_text') {
                ctx.save(); ctx.fillStyle = p.color; ctx.font = "28px 'DotGothic16', sans-serif";
                ctx.textAlign = "center"; ctx.shadowColor = "#f00"; ctx.shadowBlur = 10; ctx.strokeStyle = "#fff"; ctx.lineWidth = 3;
                ctx.strokeText(p.text, p.x, p.y); ctx.fillText(p.text, p.x, p.y); ctx.restore();
            }
            else if (p.type === 'player_miss' || p.type === 'player_dodge') {
                ctx.save(); ctx.fillStyle = p.color; ctx.font = "16px 'DotGothic16', sans-serif";
                ctx.textAlign = "center"; ctx.strokeStyle = "#000"; ctx.lineWidth = 2;
                ctx.strokeText(p.text, p.x, p.y); ctx.fillText(p.text, p.x, p.y); ctx.restore();
            }
            else if (p.type === 'player_hurt') {
                ctx.save(); ctx.fillStyle = p.color; ctx.font = "20px 'DotGothic16', sans-serif";
                ctx.textAlign = "center"; ctx.shadowColor = "#000"; ctx.shadowBlur = 2;
                ctx.strokeText(p.text, p.x, p.y); ctx.fillText(p.text, p.x, p.y); ctx.restore();
            }
            else if (p.type === 'crosshair') {
                ctx.save(); ctx.strokeStyle = "#fff"; ctx.lineWidth = 2; const r = 8; const ext = 4;
                ctx.beginPath(); ctx.arc(p.x, p.y, r, 0, Math.PI*2); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(p.x-r-ext, p.y); ctx.lineTo(p.x+r+ext, p.y);
                ctx.moveTo(p.x, p.y-r-ext); ctx.lineTo(p.x, p.y+r+ext); ctx.stroke();
                ctx.fillStyle = "red"; ctx.fillRect(p.x-1, p.y-1, 2, 2); ctx.restore();
            }
            else if (p.type === 'spark') { ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, 2, 2); }
            else if (p.type === 'nes_boom') {
                let stage = 0; let progress = p.life / p.maxLife;
                if (progress > 0.66) stage = 1; else if (progress > 0.33) stage = 2; else stage = 3;
                drawNESBoomShape(ctx, p.x, p.y, stage, p.scale, p.color);
            }
        });
    }
    function drawNESBoomShape(ctx, x, y, stage, scale, color) {
        ctx.save(); ctx.translate(x, y); ctx.scale(scale, scale); ctx.translate(-x, -y); ctx.fillStyle = color || "#FFFFFF";
        if (stage === 1) { 
            ctx.fillRect(x-4, y-4, 8, 8); ctx.fillRect(x-12, y-2, 24, 4); ctx.fillRect(x-2, y-12, 4, 24);
            ctx.fillRect(x-8, y-8, 4, 4); ctx.fillRect(x+4, y-8, 4, 4); ctx.fillRect(x-8, y+4, 4, 4); ctx.fillRect(x+4, y+4, 4, 4);
        } else if (stage === 2) {
            ctx.fillRect(x-10, y-10, 20, 20); ctx.clearRect(x-4, y-4, 8, 8);
            ctx.fillRect(x-14, y-6, 4, 12); ctx.fillRect(x+10, y-6, 4, 12);
            ctx.fillRect(x-6, y-14, 12, 4); ctx.fillRect(x-6, y+10, 12, 4);
        } else if (stage === 3) {
            ctx.fillRect(x-14, y-14, 8, 8); ctx.fillRect(x+6, y-14, 8, 8);
            ctx.fillRect(x-14, y+6, 8, 8); ctx.fillRect(x+6, y+6, 8, 8); ctx.fillRect(x-6, y-6, 12, 12);
        }
        ctx.restore();
    }

    function showResult(isWin) {
        // å¼ºåˆ¶æ˜¾ç¤ºï¼Œé‡ç½®åŠ¨ç”»
        resultScreen.style.display = 'none';
        resultScreen.offsetHeight; /* trigger reflow */
        resultScreen.style.display = 'flex';
        
        const titleDiv = document.getElementById('resultTitle');
        const descDiv = document.getElementById('resultDesc');
        
        if (isWin) {
            if (player.hp === 100) titleDiv.innerText = "å®Œç¾æ— ç‘•çš„èƒœåˆ©";
            else titleDiv.innerText = "å¥‡è¿¹èˆ¬çš„èƒœåˆ©";
            titleDiv.className = "result-title win-title";
            
            let rank = "B";
            if (player.hp === 100) rank = "S+";
            else if (player.hp >= 66) rank = "S";
            else if (player.hp >= 32) rank = "A+";
            
            descDiv.innerHTML = `å‰©ä½™ç”Ÿå‘½: ${player.hp}%<br>ä½ å‡»è´¥äº†å…¸ç‹±é•¿æ ¼èµ«ç½—æ–¯<br>è¯„ä»·: <span style="color:#ff0; font-size:20px;">${rank}</span>`;
        } else {
            titleDiv.innerText = "å½»åº•çš„ç»æœ›";
            titleDiv.className = "result-title lose-title";
            descDiv.innerHTML = `BOSS å‰©ä½™è¡€é‡: ${boss.hp}<br>å…¸ç‹±é•¿æ ¼èµ«ç½—æ–¯å‡»è´¥äº†ä½ `;
        }
    }

    function draw() {
        let renderX = 0;
        if (dodgeAnim !== 0) renderX = dodgeAnim;

        if (flash > 0 && Math.floor(frame/2)%2===0) ctx.fillStyle = flashColor;
        else ctx.fillStyle = '#050505';
        ctx.fillRect(0, 0, NES_W, NES_H);

        let dx = 0, dy = 0;
        if (shake > 0) {
            dx = (Math.random() - 0.5) * shake;
            dy = (Math.random() - 0.5) * shake;
        }

        ctx.save();
        if (Math.abs(dodgeAnim) > 1) {
            ctx.save(); ctx.translate(dx - dodgeAnim * 0.5, dy); 
            ctx.globalAlpha = 0.5; ctx.globalCompositeOperation = "lighter";
            drawUIContent(); ctx.restore();
        }
        ctx.translate(dx + renderX, dy);
        drawUIContent();
        drawParticles();
        ctx.restore();
    }

    function drawUIContent() {
        ctx.font = "12px 'DotGothic16', sans-serif";
        ctx.fillStyle = "#666"; ctx.textAlign = "center"; ctx.fillText("å…¸ç‹±é•¿æ ¼èµ«ç½—æ–¯", NES_W/2, 10);

        const bossTitle = "å…¸ç‹±é•¿æ ¼èµ«ç½—æ–¯";
        const metrics = ctx.measureText(bossTitle);
        const barW = metrics.width + 10; 
        drawBar(NES_W/2 - barW/2, 22, barW, 6, boss.hp, boss.max, '#d00');

        ctx.fillStyle = "#ffffff"; ctx.beginPath(); ctx.ellipse(NES_W/2, 125, 42, 10, 0, 0, Math.PI * 2); ctx.fill();

        if (isImageLoaded) {
            let bx = (Math.random()-0.5) * boss.recoil; let by = (Math.random()-0.5) * boss.recoil;
            ctx.save(); ctx.translate(bx, by); 
            if (boss.flashTimer > 0) { ctx.filter = "brightness(500%)"; drawBossImage(); ctx.filter = "none"; } 
            else { drawBossImage(); }
            ctx.restore();
        } else {
            // çº¢è‰²æ–¹å—å ä½
            ctx.fillStyle = "#a00"; ctx.fillRect(NES_W/2 - 20, 45, 40, 80);
        }

        const boxH = 65; const boxY = NES_H - boxH - 10;
        let swayX = 0;
        if (uiSwayTimer > 0) swayX = Math.sin(frame * 0.1) * 10 * (uiSwayTimer / 60);

        ctx.save(); ctx.translate(swayX, 0); 
        ctx.fillStyle = "#000"; ctx.fillRect(10, boxY, NES_W-20, boxH);
        ctx.strokeStyle = "#fff"; ctx.lineWidth = 2; ctx.strokeRect(10, boxY, NES_W-20, boxH);

        let isPlayerTurn = (currentState === STATE.WAITING || currentState === STATE.AIMING || currentState === STATE.FIRING);
        let isBossTurn = (currentState === STATE.ENEMY);

        if (isBossTurn) {
            ctx.fillStyle = "#000"; ctx.fillRect(10, boxY - 16, 64, 16);
            ctx.strokeStyle = "#fff"; ctx.strokeRect(10, boxY - 16, 64, 16);
            ctx.fillStyle = "#fff"; ctx.textAlign = "center"; ctx.fillText("æ ¼èµ«ç½—æ–¯", 10 + 32, boxY - 3);
        }
        if (isPlayerTurn) {
            ctx.fillStyle = "#000"; ctx.fillRect(NES_W - 10 - 36, boxY - 16, 36, 16);
            ctx.strokeStyle = "#fff"; ctx.strokeRect(NES_W - 10 - 36, boxY - 16, 36, 16);
            ctx.fillStyle = "#fff"; ctx.textAlign = "center"; ctx.fillText("ç©å®¶", NES_W - 10 - 18, boxY - 3);
        }

        ctx.textAlign = "right"; 
        let hpColor = player.hp > 35 ? '#0f0' : '#f00';
        drawBar(NES_W - 60, boxY + 10, 40, 6, player.hp, player.max, hpColor);
        ctx.fillStyle = "#fff"; ctx.fillText("HP", NES_W - 65, boxY + 16);

        ctx.fillStyle = "#fff"; ctx.textAlign = "left"; ctx.fillText(dialogue, 20, boxY + 25);
        
        if (currentState !== STATE.ENEMY && currentState !== STATE.END) {
            const bx = (NES_W - bar.w)/2; const by = boxY + 45; 
            ctx.fillStyle = "#000"; ctx.fillRect(bx, by, bar.w, bar.h);
            ctx.strokeStyle = "#666"; ctx.lineWidth = 1; ctx.strokeRect(bx, by, bar.w, bar.h);
            ctx.fillStyle = "#fff"; ctx.fillRect(bx + bar.hitStart, by+1, bar.hitW, bar.h-2);
            ctx.fillStyle = "#f00"; ctx.fillRect(bx + bar.pos - 2, by-1, 5, bar.h+2);
        }
        ctx.restore();
    }

    function drawBossImage() {
        const maxH = 85; const ratio = bossImg.width / bossImg.height;
        const drawH = maxH; const drawW = maxH * ratio;
        const x = (NES_W - drawW) / 2; const y = 45; 
        ctx.drawImage(bossImg, x, y, drawW, drawH);
    }

    function drawBar(x, y, w, h, val, max, color) {
        ctx.fillStyle = "#222"; ctx.fillRect(x, y, w, h);
        ctx.fillStyle = color;
        const wFill = Math.max(0, (val/max)*w);
        ctx.fillRect(x, y, wFill, h);
    }

    function handleInput(e) {
        if (e.target.tagName === 'BUTTON') return;
        if (e.target.id === 'manualLoader') return;
        e.preventDefault();

        if (currentState === STATE.MENU) {
            startGame();
            return;
        }

        if (currentState === STATE.WAITING) {
            currentState = STATE.AIMING;
        }
        else if (currentState === STATE.AIMING) {
            let hitL = bar.hitStart; let hitR = bar.hitStart + bar.hitW; const center = hitL + bar.hitW/2;
            if (bar.pos >= hitL && bar.pos <= hitR) {
                isHit = true; isCrit = (Math.abs(bar.pos - center) < bar.hitW * 0.25);
            } else { isHit = false; isCrit = false; }
            currentState = STATE.FIRING; shotCount = 0; shotTimer = 0;
        }
    }

    function loop(timestamp) {
        requestAnimationFrame(loop);
        if (!lastTime) lastTime = timestamp;
        const elapsed = timestamp - lastTime;
        if (elapsed > interval) {
            lastTime = timestamp - (elapsed % interval);
            frame++; update(); draw();
        }
    }

    window.addEventListener('mousedown', handleInput);
    window.addEventListener('touchstart', handleInput, {passive: false});
    startScreen.addEventListener('mousedown', handleInput);
    startScreen.addEventListener('touchstart', handleInput);

</script>
</body>
</html>